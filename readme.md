- [本文出处](https://blog.csdn.net/lmb55/article/details/78266905)
- [代码](https://github.com/usernamecantbeXXX/DistributedLock)
# 分布式锁

秒杀：多个用户争抢资源，实现线程对资源的争抢，保证高效并发，保证操作正确

- 以商品ID为唯一标识，设置互斥锁

- 枷锁 key-value 上锁，key为商品Id value无所谓；释放锁，删除key-value对 

- 阻塞式 线程上锁 特定时间内轮询

- 锁超时机制， expire命令设置超时机制 过时删除 释放锁

### 乐观锁&**`悲观锁`**

1. version

1. watch 监视 key，exec时候如果监视的key从调用watch后发生过变化，则整个事务失败

1. watch的key（事务）是对整个连接有效的，如果断开连接，监视和事务会被自动清除

1. exec discard unwatch 都会清除连接中的所有监视。

#### 事务命令

2. .multi 开启事务

2. .exec 提交事务 执行从multi到此命令前的命令队列 置客户端为非事务态

2. .discard 取消事务 

2. .watch 监视键值对 作用时 若事务提交exec时发现监视的监视对发生变化 事务将被取消

##### 实现步骤

1. 初始化商品（将商品数目添加到redis中）

1. 内部类：消费者线程（模拟一个线程抢购商品：开启redis事务，商品数量减一，提交事务，对抢到的商品做记录）

1. 初始化没秒杀操作（根据顾客数目，模拟和顾客数目相等的消费者线程）

1. 打印秒杀结果

1. 记录程序的运行时间

> 乐观锁实现：
   
   乐观锁实现  锁 = 商品的键值对 如果 exec 时 发现监视的键值 发生变化，取消事务 商品数目不改动
   
> 悲观锁实现：

   悲观锁中的锁是一个唯一标识的锁lockKey和该锁的过期时间。
   
   首先确定缓存中有商品，然后在拿数据（商品数目改动）之前先获取锁，之后对商品数目进行减一操作，操作完成释放锁，一个秒杀操作完成。
   
   这个锁是基于redis的setNX操作实现的阻塞式分布式锁
   
   
   乐观锁使用watch(key),所有的线程都可以修改商品数，但提交事务的时候如果商品数在watch期间被修改则事务需要回滚。
   悲观所在读取商品数开始就加锁，其他线程无法进行修改，需要等锁释放后才可以。
   
 > redis getset 为什么是原子性
    
    原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
    
    Redis的操作之所以是原子性的，是因为 redis是单线程的
 
 > 单jvm 多jvm
 
    一个tomcat，一个jvm，多个app也是一个jvm，不能互相调用是因为被类加载器隔离开的